//
//  MainViewController.swift
//  WeatherTestApp
//
//  Created by Aleksandr Kretov on 06.12.2022.
//  Copyright (c) 2022 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol MainDisplayLogic: AnyObject {
    func displayCurrentWeather(viewModel: MainScene.LoadWeather.ViewModel)
    func displayError(viewModel: MainScene.HandleError.ViewModel)
    func displaySearchResults(viewmodel: MainScene.LoadWeather.ViewModel)
//    func displayNewCity(viewModel: MainScene.AddCity.ViewModel)
}

class MainViewController: UIViewController, MainDisplayLogic {
    var isSearching = false
    var router: (NSObjectProtocol & MainRoutingLogic & MainDataPassing)?
    var interactor: MainBusinessLogic?

    // MARK: Private properties

    private var notificationObserver: NSObjectProtocol?
    private var viewModel: MainScene.LoadWeather.ViewModel?

    // MARK: Views

    lazy var tableView: UITableView = {
        let tableView = UITableView(frame: view.frame)
        tableView.delegate = self
        tableView.dataSource = self
        tableView.register(WeatherCell.self, forCellReuseIdentifier: WeatherCell.reuseID)
        tableView.register(SearchFieldCell.self, forCellReuseIdentifier: SearchFieldCell.reuseID)
        tableView.register(PlaceCell.self, forCellReuseIdentifier: PlaceCell.reuseID)
        tableView.separatorStyle = .none
        tableView.backgroundColor = .black
        tableView.refreshControl = refreshControl
        return tableView
    }()

    private lazy var refreshControl: UIRefreshControl = {
        let refreshControl = UIRefreshControl()
        refreshControl.addTarget(self, action: #selector(reloadData), for: .valueChanged)
        refreshControl.tintColor = .white
        let attributes: [NSAttributedString.Key: Any] = [
            .foregroundColor: UIColor.white,
            .font: UIFont.systemFont(ofSize: 16)
        ]
        refreshControl.attributedTitle = NSAttributedString(string: "Reloading forecast...",
                                                            attributes: attributes)
        return refreshControl
    }()

    private var indicator: UIActivityIndicatorView = {
        let indicator = UIActivityIndicatorView(style: .medium)
        indicator.color = .white
        indicator.startAnimating()
        indicator.hidesWhenStopped = true
        return indicator
    }()

    // MARK: Initializers

    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        setup()
    }

    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        setup()
    }

    deinit {
        if let notificationObserver {
            NotificationCenter.default.removeObserver(notificationObserver)
        }
    }

    // MARK: Private Methods

    private func setup() {
        let networkService = AFNetworkService()
        let storageService = StorageService()
        let viewController = self
        let interactor = MainInteractor(storageService: storageService,
                                        networkService: networkService)
        let presenter = MainPresenter()
        let router = MainRouter()
        viewController.interactor = interactor
        viewController.router = router
        interactor.presenter = presenter
        presenter.viewController = viewController
        router.viewController = viewController
        router.dataStore = interactor
    }

    private func setupVC() {
        view.backgroundColor = .black
        title = "Weather"
    }

    private func setupNavigationBar() {
        let appearence = UINavigationBarAppearance()
        appearence.largeTitleTextAttributes = [NSAttributedString.Key.foregroundColor: UIColor.white]
        appearence.titleTextAttributes = [NSAttributedString.Key.foregroundColor: UIColor.white]
        appearence.backgroundColor = .black
        appearence.shadowColor = nil
        navigationController?.navigationBar.prefersLargeTitles = true
        navigationController?.navigationBar.standardAppearance = appearence
        navigationItem.rightBarButtonItem = UIBarButtonItem(customView: indicator)
        // Setup back button
        let backButtonImage = UIImage(named: "back")
        navigationController?.navigationBar.backIndicatorImage = backButtonImage
        navigationController?.navigationBar.backIndicatorTransitionMaskImage = backButtonImage
        navigationItem.backBarButtonItem = UIBarButtonItem(title: "", style: .plain, target: nil, action: nil)
        navigationItem.backBarButtonItem?.tintColor = .white
    }

    @objc private func reloadData() {
        interactor?.loadData()
    }

    // MARK: - View lifecycle

    override func viewDidLoad() {
        super.viewDidLoad()
        indicator.startAnimating()
        view.addSubview(tableView)
        interactor?.loadData()
        setupVC()
        setupNavigationBar()
        notificationObserver = NotificationCenter.default.addObserver(forName: UIApplication.willEnterForegroundNotification,
                                                                      object: nil,
                                                                      queue: .main,
                                                                      using: { [unowned self] _ in reloadData() })
    }

    // MARK: Display Logic

    func displayCurrentWeather(viewModel: MainScene.LoadWeather.ViewModel) {
        self.viewModel = viewModel
        indicator.stopAnimating()
        refreshControl.endRefreshing()
        tableView.reloadSections(IndexSet(integersIn: 1 ... 2), with: .fade)
    }

    func displaySearchResults(viewmodel: MainScene.LoadWeather.ViewModel) {
        #warning("remove to interacor or presenter")
        guard let viewModel = viewModel else { return }
        var indexes = [IndexPath]()
        if viewmodel.weatherCellViewModels.count < viewModel.weatherCellViewModels.count {
            for (i, model) in viewModel.weatherCellViewModels.enumerated() {
                if !viewmodel.weatherCellViewModels.contains(where: { $0.cityName == model.cityName }) {
                    let indexPath = IndexPath(row: i, section: 1)
                    indexes.append(indexPath)
                }
            }
            self.viewModel?.weatherCellViewModels = viewmodel.weatherCellViewModels
            tableView.deleteRows(at: indexes, with: .fade)
        } else {
            for (i, model) in viewmodel.weatherCellViewModels.enumerated() {
                if !viewModel.weatherCellViewModels.contains(where: { $0.cityName == model.cityName }) {
                    let indexPath = IndexPath(row: i, section: 1)
                    indexes.append(indexPath)
                }
            }
            self.viewModel?.weatherCellViewModels = viewmodel.weatherCellViewModels
            tableView.insertRows(at: indexes, with: .fade)
        }
    }

    func displayError(viewModel: MainScene.HandleError.ViewModel) {
        let retryAction = UIAlertAction(title: "Retry", style: .default) { [weak self] _ in
            self?.reloadData()
        }
        showAlert(title: "OOPS", message: viewModel.errorMessage, actions: [retryAction])
    }

    private func deleteCity(at indexPath: IndexPath) {
        guard let id = viewModel?.weatherCellViewModels[indexPath.row].cityId else { return }
        viewModel?.weatherCellViewModels.remove(at: indexPath.row)
        tableView.deleteRows(at: [indexPath], with: .automatic)
        let request = MainScene.RemoveCity.Request(cityID: id)
        interactor?.removeCity(request: request)
    }

    private func search(_ cityName: String) {
        let request = MainScene.SearchCities.Request(searchString: cityName, isSearching: isSearching)
        interactor?.searchCity(request: request)
    }

    private func addCity(forRowAt indexPath: IndexPath) {
        view.endEditing(true)
        let request = MainScene.AddCity.Request(indexPath: indexPath)
        interactor?.addCity(request: request)
    }
}

// MARK: Extension - UITableViewDelegate

extension MainViewController: UITableViewDelegate {
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        if indexPath.section == 1 {
            router?.routeToDetailsVC()
        } else if indexPath.section == 2 {
            addCity(forRowAt: indexPath)
        }
        tableView.deselectRow(at: indexPath, animated: true)
    }

    func scrollViewWillBeginDragging(_ scrollView: UIScrollView) {
        view.endEditing(true)
    }

    func tableView(_ tableView: UITableView, trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -> UISwipeActionsConfiguration? {
        if indexPath.section == 1, indexPath.row != 0 {
            let deleteAction = UIContextualAction(style: .destructive, title: "Remove") { [weak self] _, _, completion in
                self?.deleteCity(at: indexPath)
                completion(true)
            }
            let config = UISwipeActionsConfiguration(actions: [deleteAction])
            config.performsFirstActionWithFullSwipe = true
            return config
        }
        return nil
    }
}

// MARK: Extension - UITableViewDataSource

extension MainViewController: UITableViewDataSource {
    #warning("customize section header with view")

    func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -> String? {
        if section == 2, !(viewModel?.placeCellViewModels.isEmpty ?? true) {
            return "Maybe you looking for"
        }
        return nil
    }

    func numberOfSections(in tableView: UITableView) -> Int {
        3
    }

    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        switch section {
        case 0: return 1
        case 1: return viewModel?.weatherCellViewModels.count ?? 0
        default: return viewModel?.placeCellViewModels.count ?? 0
        }
    }

    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        switch indexPath.section {
        case 0:
            guard let cell = tableView.dequeueReusableCell(withIdentifier: SearchFieldCell.reuseID) as? SearchFieldCell else { return UITableViewCell() }
            cell.delegate = self
            return cell
        case 1:
            guard
                let cell = tableView.dequeueReusableCell(withIdentifier: WeatherCell.reuseID) as? WeatherCell,
                let viewModel = viewModel?.weatherCellViewModels[indexPath.row]
            else {
                return UITableViewCell()
            }
            cell.setupCell(with: viewModel)
            return cell
        default:
            guard
                let cell = tableView.dequeueReusableCell(withIdentifier: PlaceCell.reuseID) as? PlaceCell,
                let viewModel = viewModel?.placeCellViewModels[indexPath.row]
            else {
                return UITableViewCell()
            }
            cell.setup(with: viewModel)
            return cell
        }
    }

    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
        switch indexPath.section {
        case 1: return 83
        default: return 53
        }
    }
}

// MARK: Extension - UITextFiledDelegate

extension MainViewController: UITextFieldDelegate {
    func textFieldDidChangeSelection(_ textField: UITextField) {
        guard let text = textField.text else { return }
        isSearching = !text.isEmpty
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) { [weak self] in
            self?.search(text)
        }
    }

//    #warning("NEXT UP!!!")
//
//    func textFieldDidBeginEditing(_ textField: UITextField) {
//        print(#function)
//        isSearching = true
//    }
//
//    func textFieldDidChangeSelection(_ textField: UITextField) {
//        if let text = textField.text, !text.isEmpty {
//            DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) { [weak self] in
//                self?.search(text)
//            }
//        }
//    }
//
    func textFieldDidEndEditing(_ textField: UITextField) {
        textField.text?.removeAll()
        isSearching = false
    }
    ////
//    func textFieldShouldReturn(_ textField: UITextField) -> Bool {
//        textField.resignFirstResponder()
//        return false
//    }
//
//    func textFieldShouldClear(_ textField: UITextField) -> Bool {
//        isSearching = false
//        return true
//    }
}
