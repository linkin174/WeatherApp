//
//  MainViewController.swift
//  WeatherTestApp
//
//  Created by Aleksandr Kretov on 06.12.2022.
//  Copyright (c) 2022 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol MainDisplayLogic: AnyObject {
    func displayCurrentWeather(viewModel: MainScene.LoadWeather.ViewModel)
    func displayError(viewModel: MainScene.HandleError.ViewModel)
//    func displayNewCity(viewModel: MainScene.AddCity.ViewModel)
}

class MainViewController: UIViewController, MainDisplayLogic {
    var isSearching = false
    var router: (NSObjectProtocol & MainRoutingLogic & MainDataPassing)?
    var interactor: MainBusinessLogic?

    // MARK: Private properties

    private var notificationObserver: NSObjectProtocol?
    private var viewModel: MainScene.LoadWeather.ViewModel?

    // MARK: Views

    lazy var tableView: UITableView = {
        let tableView = UITableView(frame: view.frame)
        tableView.delegate = self
        tableView.dataSource = self
        tableView.register(WeatherCell.self, forCellReuseIdentifier: WeatherCell.reuseID)
        tableView.register(SearchFieldCell.self, forCellReuseIdentifier: SearchFieldCell.reuseID)
        tableView.register(CityCell.self, forCellReuseIdentifier: CityCell.reuseID)
        tableView.separatorStyle = .none
        tableView.backgroundColor = .black
        tableView.refreshControl = refreshControl
        return tableView
    }()

    private lazy var refreshControl: UIRefreshControl = {
        let refreshControl = UIRefreshControl()
        refreshControl.addTarget(self, action: #selector(reloadData), for: .valueChanged)
        refreshControl.tintColor = .white
        let attributes: [NSAttributedString.Key: Any] = [
            .foregroundColor: UIColor.white,
            .font: UIFont.systemFont(ofSize: 16)
        ]
        refreshControl.attributedTitle = NSAttributedString(string: "Reloading forecast...",
                                                            attributes: attributes)
        return refreshControl
    }()

    private var indicator: UIActivityIndicatorView = {
        let indicator = UIActivityIndicatorView(style: .medium)
        indicator.color = .white
        indicator.startAnimating()
        indicator.hidesWhenStopped = true
        return indicator
    }()

    // MARK: Initializers

    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        setup()
    }

    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        setup()
    }

    deinit {
        if let notificationObserver {
            NotificationCenter.default.removeObserver(notificationObserver)
        }
    }

    // MARK: Private Methods

    private func setup() {
        let networkService = AFNetworkService()
        let storageService = StorageService()
        let viewController = self
        let interactor = MainInteractor(storageService: storageService,
                                        networkService: networkService)
        let presenter = MainPresenter()
        let router = MainRouter()
        viewController.interactor = interactor
        viewController.router = router
        interactor.presenter = presenter
        presenter.viewController = viewController
        router.viewController = viewController
        router.dataStore = interactor
    }

    private func setupVC() {
        view.backgroundColor = .black
        title = "Weather"
    }

    private func setupNavigationBar() {
        let appearence = UINavigationBarAppearance()
        appearence.largeTitleTextAttributes = [NSAttributedString.Key.foregroundColor: UIColor.white]
        appearence.titleTextAttributes = [NSAttributedString.Key.foregroundColor: UIColor.white]
        appearence.backgroundColor = .black
        appearence.shadowColor = nil
        navigationController?.navigationBar.prefersLargeTitles = true
        navigationController?.navigationBar.standardAppearance = appearence
        navigationItem.rightBarButtonItem = UIBarButtonItem(customView: indicator)
        // Setup back button
        let backButtonImage = UIImage(named: "back")
        navigationController?.navigationBar.backIndicatorImage = backButtonImage
        navigationController?.navigationBar.backIndicatorTransitionMaskImage = backButtonImage
        navigationItem.backBarButtonItem = UIBarButtonItem(title: "", style: .plain, target: nil, action: nil)
        navigationItem.backBarButtonItem?.tintColor = .white
    }

    @objc private func reloadData() {
        interactor?.loadData()
    }

    private func loadData() {
        interactor?.loadData()
        indicator.startAnimating()
    }

    // MARK: - View lifecycle

    override func viewDidLoad() {
        super.viewDidLoad()
        view.addSubview(tableView)
        setupVC()
        setupNavigationBar()
        loadData()
        notificationObserver = NotificationCenter.default.addObserver(forName: UIApplication.willEnterForegroundNotification,
                                                                      object: nil,
                                                                      queue: .main,
                                                                      using: { [unowned self] _ in loadData() })
    }

    // MARK: Display Logic

    func displayCurrentWeather(viewModel: MainScene.LoadWeather.ViewModel) {
        print(#function)
        DispatchQueue.main.async { [weak self] in
            self?.viewModel = viewModel
            self?.indicator.stopAnimating()
            self?.refreshControl.endRefreshing()
            self?.tableView.reloadSections(IndexSet(integersIn: 1 ... 2), with: .fade)
        }
    }

    func displayError(viewModel: MainScene.HandleError.ViewModel) {
        let retryAction = UIAlertAction(title: "Retry", style: .default) { [weak self] _ in
            self?.loadData()
        }
        showAlert(title: "OOPS", message: viewModel.errorMessage, actions: [retryAction])
    }

//    func displayNewCity(viewModel: MainScene.AddCity.ViewModel) {
//        delegate.clearTextField()
//        isSearching = false
//        self.viewModel?.weatherCellViewModels.append(viewModel.cellViewModel)
//        let indexPath = IndexPath(row: (self.viewModel?.weatherCellViewModels.count ?? 0) - 1, section: 1)
//        tableView.insertRows(at: [indexPath], with: .automatic)
//
//    }

    private func deleteCity(at indexPath: IndexPath) {
        guard let id = viewModel?.weatherCellViewModels[indexPath.row].cityId else { return }
        viewModel?.weatherCellViewModels.remove(at: indexPath.row)
        tableView.deleteRows(at: [indexPath], with: .automatic)
        let request = MainScene.RemoveCity.Request(cityID: id)
        interactor?.removeCity(request: request)
    }

    private func search(_ cityName: String) {
        let request = MainScene.SearchCities.Request(searchString: cityName, isSearching: isSearching)
        interactor?.searchCity(request: request)
    }

    private func addCity(forRowAt indexPath: IndexPath) {
        view.endEditing(true)
        guard let vm = viewModel?.cityCellViewModels[indexPath.row] else { return }
        let city = City(name: vm.cityName,
                        coord: Coord(lon: vm.longitude, lat: vm.latitude),
                        country: vm.countryName,
                        id: 0)
        let request = MainScene.AddCity.Request(city: city)
        interactor?.addCity(request: request)
    }
}

// MARK: Extension - UITableViewDelegate

extension MainViewController: UITableViewDelegate {
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        if indexPath.section == 1 {
            router?.routeToDetailsVC()
        } else if indexPath.section == 2 {
            addCity(forRowAt: indexPath)
        }
        tableView.deselectRow(at: indexPath, animated: true)
    }

    func scrollViewWillBeginDragging(_ scrollView: UIScrollView) {
        view.endEditing(true)
    }

    func tableView(_ tableView: UITableView, trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -> UISwipeActionsConfiguration? {
        if indexPath.section == 1, indexPath.row != 0 {
            let deleteAction = UIContextualAction(style: .destructive, title: "Remove") { [weak self] _, _, completion in
                self?.deleteCity(at: indexPath)
                completion(true)
            }
            let config = UISwipeActionsConfiguration(actions: [deleteAction])
            config.performsFirstActionWithFullSwipe = true
            return config
        }
        return nil
    }
}

// MARK: Extension - UITableViewDataSource

extension MainViewController: UITableViewDataSource {
    #warning("customize section header with view")

    func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -> String? {
        if section == 2, isSearching {
            return "Known cities"
        }
        return nil
    }

//    func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -> CGFloat {
//        30
//    }

    func numberOfSections(in tableView: UITableView) -> Int {
        3
    }

    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        switch section {
        case 0: return 1
        case 1: return viewModel?.weatherCellViewModels.count ?? 0
        default: return viewModel?.cityCellViewModels.count ?? 0
        }
    }

    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        switch indexPath.section {
        case 0:
            guard let cell = tableView.dequeueReusableCell(withIdentifier: SearchFieldCell.reuseID) as? SearchFieldCell else { return UITableViewCell() }
            cell.delegate = self
            return cell
        case 1:
            guard
                let cell = tableView.dequeueReusableCell(withIdentifier: WeatherCell.reuseID) as? WeatherCell,
                let viewModel = viewModel?.weatherCellViewModels[indexPath.row]
            else {
                return UITableViewCell()
            }
            cell.setupCell(with: viewModel)
            return cell
        default:
            guard
                let cell = tableView.dequeueReusableCell(withIdentifier: CityCell.reuseID) as? CityCell,
                let viewModel = viewModel?.cityCellViewModels[indexPath.row]
            else {
                return UITableViewCell()
            }
            cell.setup(viewModel: viewModel)
            return cell
        }
    }

    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
        switch indexPath.section {
        case 1: return 83
        case 2: return 33
        default: return 53
        }
    }
}

// MARK: Extension - UITextFiledDelegate

extension MainViewController: UITextFieldDelegate {

    func textFieldDidBeginEditing(_ textField: UITextField) {
        isSearching = true
    }

    func textFieldDidChangeSelection(_ textField: UITextField) {
        guard let text = textField.text, !text.isEmpty else { return }
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) { [weak self] in
            self?.search(text)
        }
    }

    func textFieldDidEndEditing(_ textField: UITextField) {
        #warning("need state to track user scrolls search view")
        textField.text = nil
        if textField.text?.isEmpty ?? true || textField.text == nil {
            isSearching = false
        }
    }

    func textFieldShouldReturn(_ textField: UITextField) -> Bool {
        textField.resignFirstResponder()
        return false
    }
}
