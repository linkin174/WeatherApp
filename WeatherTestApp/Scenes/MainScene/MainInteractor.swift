//
//  MainInteractor.swift
//  WeatherTestApp
//
//  Created by Aleksandr Kretov on 06.12.2022.
//  Copyright (c) 2022 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import CoreLocation
import UIKit

protocol MainBusinessLogic: AnyObject {
    func loadData()
    func searchCity(request: MainScene.SearchCities.Request)
    func removeCity(request: MainScene.RemoveCity.Request)
    func addCity(request: MainScene.AddCity.Request)
}

protocol MainDataStore {
    var currentWeather: [DailyForecast] { get }
    var filteredWeather: [DailyForecast] { get }
}

class MainInteractor: NSObject, MainBusinessLogic, MainDataStore, CLLocationManagerDelegate {
    // MARK: Public Properties

    var presenter: MainPresentationLogic?
    var currentWeather: [DailyForecast] = []
    var filteredWeather: [DailyForecast] = []
    var knownCities: [CityElement] = []

    // MARK: Private properties

    private let storageService: StorageServiceProtocol
    private let networkService: NetworkServiceProtocol
    private var locationManager: CLLocationManager?
    private let locationService = LocationService()
    private var cities: [City] = []

    // MARK: Initializers

    init(storageService: StorageServiceProtocol, networkService: NetworkServiceProtocol) {
        self.storageService = storageService
        self.networkService = networkService
    }

    // MARK: Interaction Logic

    func loadData() {
        cities = storageService.loadCities()
        locationManager = CLLocationManager()
        locationManager?.desiredAccuracy = kCLLocationAccuracyHundredMeters
        locationManager?.delegate = self
        
    }

    func searchCity(request: MainScene.SearchCities.Request) {
        if request.isSearching {
            let filtered = currentWeather.filter { daily in
                if let name = daily.city.name {
                    return name.lowercased().contains(request.searchString.lowercased())
                }
                return false
            }
            filteredWeather = filtered
            networkService.fetchCities(searchString: request.searchString) { knownCities in
                self.knownCities = knownCities
            }

            let response = MainScene.LoadWeather.Response(weather: filtered, knownCities: knownCities)
            presenter?.presentWeather(response: response)
        } else {
            knownCities = []
            let response = MainScene.LoadWeather.Response(weather: currentWeather, knownCities: knownCities)
            presenter?.presentWeather(response: response)
        }
    }

    func addCity(request: MainScene.AddCity.Request) {
        var city = request.city
        city.id = currentWeather.count
        storageService.add(city)
        cities = storageService.loadCities()
        #warning("something wrong with sorting")
        networkService.fetchDailyForecast(for: [city]) { [unowned self] result in
            switch result {
            case .success(let success):
                if let weather = success.first {
                    self.currentWeather.append(weather)
                    knownCities.removeAll()
                    presenter?.presentWeather(response: MainScene.LoadWeather.Response(weather: currentWeather, knownCities: knownCities))
                }
            case .failure(let error):
                let response = MainScene.HandleError.Response(error: error)
                self.presenter?.presentError(response: response)
            }
        }
    }
    
    func removeCity(request: MainScene.RemoveCity.Request) {
        guard let city = cities.first(where: { $0.id == request.cityID }) else { return }
        currentWeather.removeAll(where: { $0.city.id == city.id })
        storageService.remove(city)
    }


    // MARK: Location management

    func locationManagerDidChangeAuthorization(_ manager: CLLocationManager) {
        switch manager.authorizationStatus {
        case .authorizedAlways, .authorizedWhenInUse:
            locationManager?.requestLocation()
        case .notDetermined:
            locationManager?.requestWhenInUseAuthorization()
        default:
            loadForecast()
        }
    }

    func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
        loadForecast(with: locations.first)
    }

    func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {
        print("ERROR GETTING LOCA")
    }

    // MARK: Private Methods

    private func loadForecast(with currentLocation: CLLocation? = nil) {
        if let currentLocation {
            let currentCity = City(coord: Coord(lon: currentLocation.coordinate.longitude.magnitude,
                                                lat: currentLocation.coordinate.latitude.magnitude),
                                                id: 0)
            if cities.isEmpty {
                cities.append(currentCity)
            } else if !cities.map({$0.id}).contains(currentCity.id) {
                cities.insert(currentCity, at: 0)
            } else {
                cities[0] = currentCity
            }
        }
        networkService.fetchDailyForecast(for: cities) { [unowned self] result in
            switch result {
            case .success(let success):
                self.currentWeather = success
                    .sorted { $0.city.id ?? 0 < $1.city.id ?? 0 }
                print(currentWeather.map { $0.city.id })
                let response = MainScene.LoadWeather.Response(weather: currentWeather, knownCities: knownCities)
                self.presenter?.presentWeather(response: response)
            case .failure(let error):
                let response = MainScene.HandleError.Response(error: error)
                self.presenter?.presentError(response: response)
            }
        }
    }
}
