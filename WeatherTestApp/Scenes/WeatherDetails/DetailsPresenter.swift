//
//  DetailsPresenter.swift
//  WeatherTestApp
//
//  Created by Aleksandr Kretov on 10.12.2022.
//  Copyright (c) 2022 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol DetailsPresentationLogic {
    func presentForecast(response: Details.ShowForecast.Response)
}

class DetailsPresenter: DetailsPresentationLogic {

    weak var viewController: DetailsDisplayLogic?

    func presentForecast(response: Details.ShowForecast.Response) {
        let forecast = response.forecast
        // take only 8 first values due to each value is 3 hours forecast. 24 hours total coverege
        let dailyForecast = forecast.list.prefix(8).map { $0 }

        // finding minimum and maximum tenp from dailyForecast due to server is not providing this info for all cities
        let minMaxTempForDay = getMinMax(from: dailyForecast)

        let description = forecast.list.first?.weather.first?.main ?? "unknown"

        // MARK: HeaderViewModel
        let headerViewModel = HeaderViewModel(cityName: forecast.city.name ?? "",
                                              temp: getFormattedTemp(forecast.list.first?.main.temp ?? 0),
                                              conditionDescription: description,
                                              hiTemp: getFormattedTemp(minMaxTempForDay.max),
                                            lowTemp: getFormattedTemp(minMaxTempForDay.min))
        // MARK: HourlyViewModels
        let hourlyViewModels = dailyForecast.map { daily in
            HourlyCellViewModel(timeTitle: getTimeInAMPM(from: daily.dtTxt),
                                iconName: String(daily.weather.first?.icon?.dropLast() ?? ""),
                                tempTitle: getFormattedTemp(daily.main.temp ?? 0))
        }

        //MARK: DailyViewModels
        let dailyViewModels = getDailyViewModels(from: forecast)

        let miscViewModel = makeMiscInfoViewModel(from: forecast)

        let viewModel = Details.ShowForecast.ViewModel(headerViewModel: headerViewModel,
                                                       hourlyForecastViewModels: hourlyViewModels,
                                                       dailyForecastViewModels: dailyViewModels,
                                                       miscInfoViewModel: miscViewModel)
        viewController?.displayDetailedForecast(viewModel: viewModel)
    }

    private func makeMiscInfoViewModel(from forecast: DailyForecast) -> MiscInfoViewModelProtocol {
        let currentDayForecast = forecast.list.first
        var weatherDesription: String {
            guard let description = forecast.list.first?.weather.first?.description else { return "unknown" }
            var text = "Right now is \(description)."
            if let gust = forecast.list.first?.wind.gust {
                text += " Wind gusts are up to \(gust) m/s"
            }
            print(text)
            return text
        }
        let sunriseTime = getTimeFromSecondsUTC(seconds: forecast.city.sunrise)
        let sunsetTime = getTimeFromSecondsUTC(seconds: forecast.city.sunset)
        let chanceOfRain = String((currentDayForecast?.pop ?? 0.0) * 100) + "%"
        let humidity = String(currentDayForecast?.main.humidity ?? 0) + "%"
        let feelsLike = getFormattedTemp(currentDayForecast?.main.feelsLike ?? 0.0, isDeegreeSign: true)
        var popVolume: String {
            var volume = 0.0
            if let snowVolume = currentDayForecast?.snow?.threeHours {
                volume = snowVolume
            } else if let rainVolume = currentDayForecast?.rain?.threeHours {
                volume = rainVolume
            }
            return String(volume) + " mm"
        }
        let pressure = String(forecast.list.first?.main.pressure ?? 0) + " hPa"
        var visibility: String {
            guard let value = forecast.list.first?.visibility else { return "--" }
            if value < 1000 {
                return String(value) + " m"
            } else {
                return String(value / 1000) + " km"
            }
        }
        return MiscInfoViewModel(weatherDescription: weatherDesription,
                                 sunriseTime: sunriseTime,
                                 sunsetTime: sunsetTime,
                                 chanceOfRain: chanceOfRain,
                                 humidity: humidity,
                                 wind: getWindDescription(from: currentDayForecast),
                                 feelsLike: feelsLike,
                                 precipitation: popVolume,
                                 pressure: pressure,
                                 visibility: visibility,
                                 uvIndex: "0")
    }

    private func getWindDescription(from forecast: Hourly?) -> String {
        guard let forecast else { return "--" }
        guard let speed = forecast.wind.speed else { return "--" }
        let speedDesription = "\(String(round(speed))) m/s"

        guard let deg = forecast.wind.deg else { return speedDesription }
        var direction = ""
        switch deg {
        case 20...30: direction = "N/NE"
        case 40...50: direction = "NE"
        case 60...70: direction = "E/NE"
        case 80...100: direction = "E"
        case 110...120: direction = "E/SE"
        case 130...140: direction = "SE"
        case 150...160: direction = "S/SE"
        case 170...190: direction = "S"
        case 200...210: direction = "S/SW"
        case 220...230: direction = "SW"
        case 240...250: direction = "W/SW"
        case 260...280: direction = "W"
        case 290...300: direction = "W/NW"
        case 310...320: direction = "NW"
        case 330...340: direction = "N/NW"
        default: direction = "N"
        }
        return "\(direction) \(speedDesription)"
    }

    private func getTimeFromSecondsUTC(seconds: Int?) -> String {
        guard let seconds else { return "00:00" }
        let date = Date(timeIntervalSince1970: Double(seconds))
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "HH:mm"
        return dateFormatter.string(from: date)
    }

    private func getForecastForCurrentDay(from forecast: DailyForecast) -> [Hourly] {
        let days = Dictionary(grouping: forecast.list) { getDayName(from: $0) }
            .sorted { $0.value.first?.dt ?? 0 < $1.value.first?.dt ?? 0 }
        guard let first = days.first?.value else { return [] }
        return first
    }

    private func getDailyViewModels(from forecast: DailyForecast) -> [DayForecastViewModel] {
        Dictionary(grouping: forecast.list) { getDayName(from: $0) }
            .sorted { $0.value.first?.dt ?? 0 < $1.value.first?.dt ?? 0 }
            .reduce(into: [DayForecastViewModel]()) { partialResult, element in
                let temps = getMinMax(from: element.value)
                let maxTemp = getFormattedTemp(temps.max)
                let minTemp = getFormattedTemp(temps.min)
                let icon = getWeatherIconForDay(from: element.value)
                let pop = getPrecicipationAvarage(from: element.value)
                let viewModel = DayForecastViewModel(dayName: element.key,
                                                     iconName: icon,
                                                     precipitationTitle: pop,
                                                     dayTemp: maxTemp,
                                                     nightTemp: minTemp)
                partialResult.append(viewModel)
            }
    }

    private func getPrecicipationAvarage(from dailyForecast: [Hourly]) -> String? {
        let pop = dailyForecast.map { $0.pop }
        let avarege = pop.reduce(0, +) / Double(pop.count)
        let roundedToPercents = Int(avarege * 100)
        return roundedToPercents != 0 ? "\(roundedToPercents)%" : nil
    }

    // Find most frequent weather icon condition.
    private func getWeatherIconForDay(from dailyForecast: [Hourly]) -> String {
        let iconName = dailyForecast.reduce(into: String()) { partialResult, daily in
            partialResult = Dictionary(grouping: dailyForecast) { $0.weather.first?.icon }
                            .sorted { $0.value.count >  $1.value.count }
                            .first?.value.first?.weather.first?.icon ?? ""
        }
        return String(iconName.dropLast())
    }

    private func getDayName(from hourlyForecast: Hourly) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy-MM-dd HH:mm:ss"
        guard let date = formatter.date(from: hourlyForecast.dtTxt ) else { return "Day" }
        formatter.dateFormat = "EEEE"
        return formatter.string(from: date)
    }

    // This is needed because API sends min and max temps for only some cities. In all other cases they are equal
    // Lets fix this by finding min and max temp in hourly forecasts of current day
    private func getMinMax(from dailyForecast: [Hourly]) -> (min: Double, max: Double) {
        let min = dailyForecast.min { $0.main.temp ?? 0 < $1.main.temp ?? 0 }?.main.temp ?? 0
        let max = dailyForecast.max { $0.main.temp ?? 0 < $1.main.temp ?? 0 }?.main.temp ?? 0
        return (min, max)
    }

    private func getTimeInAMPM(from time: String?) -> String {
        guard let time else { return "--" }
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy-MM-dd HH:mm:ss"
        guard let date = formatter.date(from: time) else { return "--" }
        formatter.dateFormat = "ha"
        let str = formatter.string(from: date)
        return str
    }

    private func getFormattedTemp(_ temp: Double, isDeegreeSign: Bool = true) -> String {
        if round(temp) == 0 {
            // If temp is Zero ignore "-" sign and return 0
            return NSString(format: "0%@" as NSString, "\u{00B0}") as String
        } else {
            let roundedTemp = String(format: "%.f", temp)
            return NSString(format: "\(roundedTemp)%@" as NSString, "\u{00B0}") as String
        }
    }
}
