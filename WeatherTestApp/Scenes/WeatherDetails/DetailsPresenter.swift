//
//  DetailsPresenter.swift
//  WeatherTestApp
//
//  Created by Aleksandr Kretov on 10.12.2022.
//  Copyright (c) 2022 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol DetailsPresentationLogic {
    func presentForecast(response: Details.ShowForecast.Response)
    func presentError(response: Details.HandleError.Response)
    func presentCurrentWeather(response: Details.ShowCurrentWeather.Response)
}

class DetailsPresenter: DetailsPresentationLogic {
    weak var viewController: DetailsDisplayLogic?

    private let formatter = DateFormatter()

    func presentForecast(response: Details.ShowForecast.Response) {
        print("DAILY \(response.forecast.list.map { $0.dtTxt })")
        let forecast = response.forecast
        // take only 8 first values due to each value is 3 hours forecast. 24 hours total coverege
        let dailyForecast = forecast.list.prefix(8).map { $0 }

        // finding minimum and maximum tenp from dailyForecast due to server is not providing this info for all cities
        let minMaxTempForDay = getMinMax(from: dailyForecast)

        let description = forecast.list.first?.weather.first?.main ?? "unknown"

        // MARK: HeaderViewModel

//        let headerViewModel = HeaderViewModel(cityName: forecast.city.name ?? "",
//                                              temp: getFormattedTemp(forecast.list.first?.main.temp ?? 0),
//                                              conditionDescription: description,
//                                              hiTemp: getFormattedTemp(minMaxTempForDay.max),
//                                              lowTemp: getFormattedTemp(minMaxTempForDay.min))

        // MARK: HourlyViewModels

        let hourlyViewModels = dailyForecast.map { daily in
            HourlyCellViewModel(timeTitle: getTimeInAMPM(from: daily.dtTxt, timezoneShift: forecast.city.timezone),
                                iconName: String(daily.weather.first?.icon?.dropLast() ?? ""),
                                tempTitle: getFormattedTemp(daily.main.temp ?? 0, isDeegreeSign: false))
        }

        // MARK: DailyViewModels

        let dailyViewModels = makeDailyViewModels(from: forecast)

        let miscViewModel = makeMiscInfoViewModel(from: forecast)

        let viewModel = Details.ShowForecast.ViewModel(hourlyForecastViewModels: hourlyViewModels,
                                                    dailyForecastViewModels: dailyViewModels,
                                                       miscInfoViewModel: miscViewModel)
        viewController?.displayDetailedForecast(viewModel: viewModel)
    }

    func presentError(response: Details.HandleError.Response) {
        #warning("continue")
    }

    func presentCurrentWeather(response: Details.ShowCurrentWeather.Response) {

        let temp = getFormattedTemp(response.weather.main?.temp ?? 0)
        let hiTemp = getFormattedTemp(response.weather.main?.tempMax ?? 0)
        let loTemp = getFormattedTemp(response.weather.main?.tempMin ?? 0)
        guard let description = response.weather.weather?.first?.main?.description else { return }
        let headerViewModel = HeaderViewModel(cityName: response.weather.name ?? "--",
                                              temp: temp,
                                              conditionDescription: description,
                                              hiTemp: hiTemp,
                                              lowTemp: loTemp)
        let viewModel = Details.ShowCurrentWeather.ViewModel(headerViewModel: headerViewModel)
        viewController?.displayCurrentWeather(viewModel: viewModel)
    }

    private func makeMiscInfoViewModel(from forecast: DailyForecast) -> MiscInfoViewModelProtocol {
        let currentDayForecast = forecast.list.first
        var weatherDesription: String {
            guard let description = forecast.list.first?.weather.first?.description else { return "Great weather!" }
            var text = "Right now is \(description)."
            if let gust = forecast.list.first?.wind.gust {
                text += " Wind gusts are up to \(Int(gust)) m/s"
            }
            return text
        }

        let sunriseTime = getTimeFromSecondsUTC(seconds: forecast.city.sunrise)
        let sunsetTime = getTimeFromSecondsUTC(seconds: forecast.city.sunset)

        var chanceOfRain: String {
            guard let pop = currentDayForecast?.pop else { return "0 %" }
            return String(format: "%.f", pop * 100) + " %"
        }

        let humidity = String(currentDayForecast?.main.humidity ?? 0) + "%"
        let feelsLike = getFormattedTemp(currentDayForecast?.main.feelsLike ?? 0.0, isDeegreeSign: true)
        var isRain: Bool {
            forecast.list.first?.main.temp ?? 0 > 0
        }
        var popVolume: String {
            if let snowVolume = currentDayForecast?.snow?.threeHours {
                return String(snowVolume) + " mm"
            } else if let rainVolume = currentDayForecast?.rain?.threeHours {
                return String(rainVolume) + " mm"
            }
            return "0 mm"
        }
        let pressure = String(forecast.list.first?.main.pressure ?? 0) + " hPa"
        var visibility: String {
            guard let value = forecast.list.first?.visibility else { return "--" }
            if value < 1000 {
                return String(value) + " m"
            } else {
                return String(value / 1000) + " km"
            }
        }

        return MiscInfoViewModel(weatherDescription: weatherDesription,
                                 sunriseTime: sunriseTime,
                                 sunsetTime: sunsetTime,
                                 chanceOfPop: chanceOfRain,
                                 humidity: humidity,
                                 wind: getWindDescription(from: currentDayForecast),
                                 feelsLike: feelsLike,
                                 precipitation: popVolume,
                                 pressure: pressure,
                                 visibility: visibility,
                                 uvIndex: "0",
                                 isRain: isRain)
    }

    private func getWindDescription(from forecast: Hourly?) -> String {
        guard let forecast else { return "--" }
        guard let speed = forecast.wind.speed else { return "--" }
        let speedDesription = String(format: "%.f", speed) + " m/s"

        guard let deg = forecast.wind.deg else { return speedDesription }
        var direction = ""
        switch deg {
        case 20...30: direction = "N/NE"
        case 40...50: direction = "NE"
        case 60...70: direction = "E/NE"
        case 80...100: direction = "E"
        case 110...120: direction = "E/SE"
        case 130...140: direction = "SE"
        case 150...160: direction = "S/SE"
        case 170...190: direction = "S"
        case 200...210: direction = "S/SW"
        case 220...230: direction = "SW"
        case 240...250: direction = "W/SW"
        case 260...280: direction = "W"
        case 290...300: direction = "W/NW"
        case 310...320: direction = "NW"
        case 330...340: direction = "N/NW"
        default: direction = "N"
        }
        return "\(direction) \(speedDesription)"
    }

    private func getTimeFromSecondsUTC(seconds: Int?) -> String {
        guard let seconds else { return "00:00" }
        let date = Date(timeIntervalSince1970: Double(seconds))
        formatter.dateFormat = "HH:mm"
        return formatter.string(from: date)
    }

    private func makeDailyViewModels(from forecast: DailyForecast) -> [DayForecastViewModel] {
        let dict = Dictionary(grouping: forecast.list) { getDayName(from: $0.dtTxt, timezoneShift: forecast.city.timezone) }
            .sorted { $0.value.first?.dt ?? 0 < $1.value.first?.dt ?? 0 }
        return dict
            .reduce(into: [DayForecastViewModel]()) { partialResult, element in
                let index = dict.firstIndex(where: { $0.key == element.key })
                let temps = getMinMax(from: element.value)
                let maxTemp = getFormattedTemp(temps.max)
                let minTemp = getFormattedTemp(temps.min)
                let icon = getWeatherIconForDay(from: element.value)
                let pop = getPrecicipationAvarage(from: element.value)
                let viewModel = DayForecastViewModel(dayName: index == 0 ? "Today" : element.key,
                                                     iconName: icon,
                                                     precipitationTitle: pop,
                                                     dayTemp: maxTemp,
                                                     nightTemp: minTemp)
                partialResult.append(viewModel)
            }
    }

    private func getPrecicipationAvarage(from dailyForecast: [Hourly]) -> String? {
        let pop = dailyForecast.map { $0.pop }
        let avarege = pop.reduce(0, +) / Double(pop.count)
        let roundedToPercents = Int(avarege * 100)
        return roundedToPercents != 0 ? "\(roundedToPercents)%" : nil
    }

    // Find most frequent weather icon condition.
    private func getWeatherIconForDay(from dailyForecast: [Hourly]) -> String {
        let iconName = dailyForecast.reduce(into: String()) { partialResult, _ in
            partialResult = Dictionary(grouping: dailyForecast) { $0.weather.first?.icon }
                .sorted { $0.value.count > $1.value.count }
                .first?.value.first?.weather.first?.icon ?? ""
        }
        return String(iconName.dropLast())
    }

    private func getDayName(from time: String?, timezoneShift: Int?) -> String {
        formatter.dateFormat = "yyyy-MM-dd HH:mm:ss"
        guard
            let time,
            let timezoneShift,
            let date = formatter.date(from: time)?.addingTimeInterval(Double(timezoneShift))
        else {
            return "--"
        }
        formatter.dateFormat = "EEEE"
        let str = formatter.string(from: date)
        return str
//        formatter.dateFormat = "yyyy-MM-dd HH:mm:ss"
//        guard let date = formatter.date(from: hourlyForecast.dtTxt)?.addingTimeInterval(Double(timeZoneShift!)) else { return "Day" }
//        formatter.dateFormat = "EEEE"
//        return formatter.string(from: date)
    }

    // This is needed because API sends min and max temps for only some cities. In all other cases they are equal
    // Lets fix this by finding min and max temp in hourly forecasts of current day
    private func getMinMax(from dailyForecast: [Hourly]) -> (min: Double, max: Double) {
        let min = dailyForecast.min { $0.main.temp ?? 0 < $1.main.temp ?? 0 }?.main.temp ?? 0
        let max = dailyForecast.max { $0.main.temp ?? 0 < $1.main.temp ?? 0 }?.main.temp ?? 0
        return (min, max)
    }

    private func getTimeInAMPM(from time: String?, timezoneShift: Int?) -> String {
        formatter.dateFormat = "yyyy-MM-dd HH:mm:ss"
        guard
            let time,
            let timezoneShift,
            let date = formatter.date(from: time)?.addingTimeInterval(Double(timezoneShift))
        else {
            return "--"
        }
        formatter.dateFormat = "ha"
        let str = formatter.string(from: date)
        return str
    }

    private func getFormattedTemp(_ temp: Double, isDeegreeSign: Bool = true) -> String {
        if round(temp) == 0 {
            // If temp is Zero ignore "-" sign and return 0
            return NSString(format: "0%@" as NSString, "\u{00B0}") as String
        } else {
            let roundedTemp = String(format: "%.f", temp)
            return NSString(format: "\(roundedTemp)%@" as NSString, "\u{00B0}") as String
        }
    }
}
