//
//  DetailsPresenter.swift
//  WeatherTestApp
//
//  Created by Aleksandr Kretov on 10.12.2022.
//  Copyright (c) 2022 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol DetailsPresentationLogic {
    func presentCurrentWeather(response: Details.ShowCurrentWeather.Response)
    func presentForecast(response: Details.ShowForecast.Response)
    func presentError(response: Details.HandleError.Response)
}

class DetailsPresenter: DetailsPresentationLogic {
    // MARK: - Public Properties

    weak var viewController: DetailsDisplayLogic?

    // MARK: - Private Properties

    private let formatter = DateFormatter()

    // MARK: - Presentation Logic
    
    func presentCurrentWeather(response: Details.ShowCurrentWeather.Response) {
        let temp = getFormattedTemp(response.weather.main.temp ?? 0)
        let description = response.weather.weather.first?.main?.description
        let hiTemp = getFormattedTemp(response.weather.main.tempMax ?? 0)
        let loTemp = getFormattedTemp(response.weather.main.tempMin ?? 0)
        let headerViewModel = HeaderViewModel(cityName: response.weather.name ?? "--",
                                              temp: temp,
                                              conditionDescription: description ?? "---",
                                              hiTemp: hiTemp,
                                              lowTemp: loTemp)
        let viewModel = Details.ShowCurrentWeather.ViewModel(headerViewModel: headerViewModel)
        viewController?.displayCurrentWeather(viewModel: viewModel)
    }

    func presentForecast(response: Details.ShowForecast.Response) {
//        print("DAILY \(response.forecast.list.map { $0.dtTxt })")
        let forecast = response.forecast

        let hourlyViewModels = makeHourlyViewModels(from: forecast)

        let dailyViewModels = makeDailyViewModels(from: forecast)

        let miscViewModel = makeMiscInfoViewModel(from: response.currentweather, and: forecast.list.first)

        let viewModel = Details.ShowForecast.ViewModel(hourlyForecastViewModels: hourlyViewModels,
                                                       dailyForecastViewModels: dailyViewModels,
                                                       miscInfoViewModel: miscViewModel)

        viewController?.displayDetailedForecast(viewModel: viewModel)
    }

    func presentError(response: Details.HandleError.Response) {
        let viewModel = Details.HandleError.ViewModel(errorMessage: response.error.localizedDescription)
        viewController?.displayError(viewModel: viewModel)
    }


    // MARK: - Private Methods

    private func makeHourlyViewModels(from: DailyForecast, quantity: Int = 16) -> [HourlyCellViewModelProtocol] {
        let forecastForPeriod = from.list.prefix(quantity).map { $0 }
        return forecastForPeriod.map { hourly in
            HourlyCellViewModel(timeTitle: getTimeInAMPM(from: hourly.dtTxt, timezoneShift: from.city.timezone),
                                iconName: String(hourly.weather.first?.icon?.dropLast() ?? ""),
                                tempTitle: getFormattedTemp(hourly.main.temp ?? 0))
        }
    }

    private func makeDailyViewModels(from forecast: DailyForecast) -> [DayForecastViewModel] {
        Dictionary(grouping: forecast.list) { getDayName(from: $0.dtTxt, timezoneShift: forecast.city.timezone) }
            .sorted { $0.value.first?.dt ?? 0 < $1.value.first?.dt ?? 0 }
            .reduce(into: [DayForecastViewModel]()) { partialResult, element in
                let temps = getMinMax(from: element.value)
                let maxTemp = getFormattedTemp(temps.max)
                let minTemp = getFormattedTemp(temps.min)
                let icon = getWeatherIconForDay(from: element.value)
                let pop = getPrecicipationAvarage(from: element.value)
                let viewModel = DayForecastViewModel(dayName: element.key,
                                                     iconName: icon,
                                                     precipitationTitle: pop,
                                                     dayTemp: maxTemp,
                                                     nightTemp: minTemp)
                partialResult.append(viewModel)
                partialResult[0].dayName = "Today"
            }
    }

    private func makeMiscInfoViewModel(from currentWeather: CurrentWeather, and hourly: Hourly?) -> MiscInfoViewModelProtocol {
        var weatherDescription: String {
            guard let description = currentWeather.weather.first?.description else { return "Right now is great weather!" }
            var text = "Right now is \(description)."
            if let gust = currentWeather.wind.gust {
                text += " Wind gusts are up to \(Int(gust)) m/s."
            }
            return text
        }

        let sunriseTime = getTimeFromSecondsUTC(seconds: currentWeather.sys.sunrise)

        let sunsetTime = getTimeFromSecondsUTC(seconds: currentWeather.sys.sunset)

        var chanceOfPop: String {
            if let hourly {
                return "\(Int(hourly.pop * 100)) %"
            } else {
                return "0 %"
            }
        }

        let humidity = String(currentWeather.main.humidity ?? 0) + "%"

        let wind = getWindDescription(from: currentWeather.wind)

        let feelsLike = getFormattedTemp(currentWeather.main.feelsLike ?? 0)

        var isRain: Bool {
            currentWeather.main.temp ?? 0 > 0
        }

        var popVolume: String {
            if let snowVolume = currentWeather.snow?.oneHour {
                return String(Int(snowVolume)) + " mm"
            } else if let rainVolume = currentWeather.rain?.oneHour {
                return String(Int(rainVolume)) + " mm"
            }
            return "0 mm"
        }

        let pressure = String(currentWeather.main.pressure ?? 0) + " hPa"

        var visability: String {
            let value = currentWeather.visibility
            if value < 1000 {
                return String(value) + " m"
            } else {
                return String(value / 1000) + " km"
            }
        }

        return MiscInfoViewModel(weatherDescription: weatherDescription,
                                 sunriseTime: sunriseTime,
                                 sunsetTime: sunsetTime,
                                 chanceOfPop: chanceOfPop,
                                 humidity: humidity,
                                 wind: wind,
                                 feelsLike: feelsLike,
                                 precipitation: popVolume,
                                 pressure: pressure,
                                 visibility: visability,
                                 uvIndex: "0",
                                 isRain: isRain)
    }


    private func getWindDescription(from wind: Wind?) -> String {
        guard let wind else { return "--" }
        guard let speed = wind.speed else { return "--" }
        let speedDesription = String(format: "%.f", speed) + " m/s"

        guard let deg = wind.deg else { return speedDesription }
        var direction = ""
        switch deg {
        case 20...30: direction = "N/NE"
        case 40...50: direction = "NE"
        case 60...70: direction = "E/NE"
        case 80...100: direction = "E"
        case 110...120: direction = "E/SE"
        case 130...140: direction = "SE"
        case 150...160: direction = "S/SE"
        case 170...190: direction = "S"
        case 200...210: direction = "S/SW"
        case 220...230: direction = "SW"
        case 240...250: direction = "W/SW"
        case 260...280: direction = "W"
        case 290...300: direction = "W/NW"
        case 310...320: direction = "NW"
        case 330...340: direction = "N/NW"
        default: direction = "N"
        }
        return "\(direction) \(speedDesription)"
    }

    private func getTimeFromSecondsUTC(seconds: Int?) -> String {
        guard let seconds else { return "00:00" }
        let date = Date(timeIntervalSince1970: Double(seconds))
        formatter.dateFormat = "HH:mm"
        return formatter.string(from: date)
    }

    private func getPrecicipationAvarage(from dailyForecast: [Hourly]) -> String? {
        // Calculate avarage precipitation chance
        let pop = dailyForecast.map { $0.pop }
        let avarege = pop.reduce(0, +) / Double(pop.count)
        let roundedToPercents = Int(avarege * 100)
        return roundedToPercents != 0 ? "\(roundedToPercents)%" : nil
    }
    private func getWeatherIconForDay(from dailyForecast: [Hourly]) -> String {
        // Find most recent weather icon for that day
        let iconName = dailyForecast.reduce(into: String()) { partialResult, _ in
            partialResult = Dictionary(grouping: dailyForecast) { $0.weather.first?.icon }
                .sorted { $0.value.count > $1.value.count }
                .first?.value.first?.weather.first?.icon ?? ""
        }
        return String(iconName.dropLast())
    }

    private func getDayName(from time: String?, timezoneShift: Int?) -> String {
        guard let date = getDate(from: time, timezoneShift: timezoneShift) else { return "--" }
        formatter.dateFormat = "EEEE"
        let str = formatter.string(from: date)
        return str
    }

    private func getTimeInAMPM(from time: String?, timezoneShift: Int?) -> String {
        guard let date = getDate(from: time, timezoneShift: timezoneShift) else { return "--" }
        formatter.dateFormat = "ha"
        let str = formatter.string(from: date)
        return str
    }

    private func getDate(from string: String?, timezoneShift: Int?) -> Date? {
        formatter.dateFormat = "yyyy-MM-dd HH:mm:ss"
        guard
            let string,
            let timezoneShift,
            let date = formatter.date(from: string)?.addingTimeInterval(Double(timezoneShift))
        else {
            return nil
        }
        return date
    }

    // This is needed because API sends min and max temps for only some cities. In all other cases they are equal
    // Lets fix this by finding min and max temp in hourly forecasts of current day
    private func getMinMax(from dailyForecast: [Hourly]) -> (min: Double, max: Double) {
        let min = dailyForecast.min { $0.main.temp ?? 0 < $1.main.temp ?? 0 }?.main.temp ?? 0
        let max = dailyForecast.max { $0.main.temp ?? 0 < $1.main.temp ?? 0 }?.main.temp ?? 0
        return (min, max)
    }

    private func getFormattedTemp(_ temp: Double, isDeegreeSign: Bool = true) -> String {
        if round(temp) == 0 {
            // If temp is Zero ignore "-" sign and return 0
            return NSString(format: "0%@" as NSString, "\u{00B0}") as String
        } else {
            let roundedTemp = String(format: "%.f", temp)
            return NSString(format: "\(roundedTemp)%@" as NSString, "\u{00B0}") as String
        }
    }
}
